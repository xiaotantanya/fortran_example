#include "niobasic/vtiFile.h"

void n_vtiFile_4D_double_write_f(int *x, int *y, int *z, int *c, double **data, const char *fileName)
{
    n_vtiFile_4D_double_write(*x, *y, *z, *c, NPTR2ARR4D(double,*data,*x, *y, *z, *c), fileName);
}

void n_vtiFile_4D_double_write(int x, int y, int z, int c, double data[x][y][z][c], const char *fileName)
{
    xmlTextWriterPtr writer;
    int rc=0;
    char temp[32];
    char temp1[32];
    int index[c];
    int i=0;
    remove(fileName);
    ControlFilePtr cf = n_ControlFile_init("whateverfile.xml", "VTKFile");

    xmlNewProp(cf->root, BAD_CAST("type"), BAD_CAST("ImageData"));
    writer = xmlNewTextWriterTree(cf->doc, cf->root, 0);

    rc = xmlTextWriterStartDocument(writer, NULL, MY_VTI_ENCODING, NULL);
    rc = xmlTextWriterWriteComment(writer, BAD_CAST "This file is generated by NIOBASIC VTI_RectilinearGrid_write");
    rc = xmlTextWriterStartElement(writer, BAD_CAST "ImageData");

    sprintf(temp, "0 %i 0 %i 0 %i", x - 1, y - 1, z - 1);
    rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "WholeExtent", BAD_CAST temp);
    rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "Origin", BAD_CAST "0 0 0");
    rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "Spacing", BAD_CAST "1 1 1");
    rc = xmlTextWriterStartElement(writer, BAD_CAST "Piece");
    rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "Extent", BAD_CAST temp);
    rc = xmlTextWriterStartElement(writer, BAD_CAST "PointData");
    rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "Scalars", BAD_CAST "scalar_data_0");

    for (i = 0; i < c; i++)
    {
        rc = xmlTextWriterStartElement(writer, BAD_CAST "DataArray");
        rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "type", BAD_CAST "Float64");
        sprintf(temp1, "%i", i);
        n_string_join(temp, "scalar_data", temp1, "_");
        rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "Name", BAD_CAST temp);
        rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "format", BAD_CAST "ascii");
        // rc = xmlTextWriterWriteString(writer, dataString);
        n_string_join(temp, "DATAARRAYPLACEHOLDER", temp1, "_");
        rc = xmlTextWriterWriteString(writer, BAD_CAST temp);
        rc = xmlTextWriterEndElement(writer); // For DataArray
    }

    rc = xmlTextWriterEndElement(writer);  // For piece
    rc = xmlTextWriterEndElement(writer);  // For RectilinearGrid
    rc = xmlTextWriterEndDocument(writer); // For VTIFile

    xmlFreeTextWriter(writer);

    xmlChar *xmlbuff;
    int buffersize;

    xmlDocDumpMemoryEnc(cf->doc, &xmlbuff, &buffersize, MY_VTI_ENCODING);
    char output[MAX_STRING] = {'\0'};
    char outputHold[MAX_STRING] = {'\0'};
    char part1[MAX_STRING] = {'\0'};
    char part2[MAX_STRING] = {'\0'};
    char partHold[MAX_STRING] = {'\0'};
    strcpy(output, (char *)xmlbuff);
    strcpy(outputHold, (char *)xmlbuff);
    xmlFree(xmlbuff);

    n_ControlFile_free(cf);
    for (i = 0; i < c; i++)
    {
        sprintf(temp1, "%i", i);
        n_string_join(temp, "DATAARRAYPLACEHOLDER", temp1, "_");
        index[i] = n_substring_index(output, temp);
    }

    strncpy(part1, output, index[0]);
    strcpy(part2, output + index[c - 1] + 22);

    FILE *fp;
    fp = fopen(fileName, "a");
    fputs(part1, fp);
    int j=0;
    int k=0;
    int l=0;
    for (l = 0; l < c; l++)
    {
        memset(temp, '\0', sizeof(temp));
        for (k = 0; k < z; k++)
        {
            for (j = 0; j < y; j++)
            {
                for (i = 0; i < x; i++)
                {
                    sprintf(temp, MY_VTI_FORMAT_SCIENTIFIC, data[i][j][k][l]);
                    fputs(temp, fp);
                }
            }
        }

        if (l < c - 1)
        {
            strncpy(partHold, outputHold + index[l] + 22, index[l + 1] - index[l] - 22);
            fputs(partHold, fp);
        }
    }
    fputs(part2, fp);
    fclose(fp);
}

void n_vtiFile_4D_double_read_f(int *x, int *y, int *z, int *c, double **data, const char *fileName)
{
    n_vtiFile_4D_double_read(*x, *y, *z, *c, NPTR2ARR4D(double,*data,*x, *y, *z, *c), fileName);
}

void n_vtiFile_4D_double_read(int x, int y, int z, int c, double data[x][y][z][c], const char *fileName)
{

    int strSize = 512;
    char temp[strSize + 1];
    memset(temp, '\0', strSize + 1);
    int cmpLength = 9;
    char cmpStr[cmpLength + 1];
    memset(cmpStr, '\0', cmpLength + 1);
    strcpy(cmpStr, "DataArray");
    int endReached = 0; // become 1 when reach the end
    int ignoreNext = 0; // become 1 when the odd number of substring is found
    int dataCount = 0;

    int pos = 0;
    // int intTemp = 0;
    FILE *fp;
    fp = fopen(fileName, "r");
    if (fp == NULL)
    {
        ZF_LOGD("Failed: ");
    }

    while (!endReached)
    {
        // ZF_LOGD("before read %i",strSize);
        memset(temp, '\0', strSize + 1);
        fread(temp, strSize, 1, fp);
        // ZF_LOGD("before read %i",strSize);

        // ZF_LOGD("the temp %li %s %i",ftell(fp),temp, n_substring_index(temp,cmpStr));
        // ZF_LOGD("before read %i",strSize);
        if (feof(fp))
        {
            endReached = 1;
            ZF_LOGD("reached the end %li %s", ftell(fp), temp);
        }

        pos = n_substring_index(temp, cmpStr);
        if (pos != -1)
        {
            // ZF_LOGD("Find dataarray %s",temp);
            // Go to end of the DataArray, next we need to find the >
            fseek(fp, -strSize, SEEK_CUR);
            // ZF_LOGD("The data array at beginning %li %i", ftell(fp), pos);
            // Go to the end of the existing substring
            fseek(fp, pos + cmpLength, SEEK_CUR);
            // ZF_LOGD("The data array with shift %li", ftell(fp));

            // Read the file again to find >
            memset(temp, '\0', strSize + 1);
            fread(temp, strSize, 1, fp);
            pos = n_substring_index(temp, ">");
            fseek(fp, -strSize, SEEK_CUR);
            fseek(fp, pos + 1, SEEK_CUR);
            // ZF_LOGD("The data array with shift %li %i %i", ftell(fp),pos,ignoreNext);

            if (ignoreNext)
            {
                ignoreNext = 0;
                ZF_LOGD("Find dataarray is ignored %i",ignoreNext);
            }
            else
            {
                ignoreNext = 1;
                ZF_LOGD("Find dataarray is not ignored %i",ignoreNext);
                // Start to read the data
                size_t i=0;
                size_t j=0;
                size_t k=0;

                for (k = 0; k < z; k++)
                {
                    for (j = 0; j < y; j++)
                    {
                        for (i = 0; i < x; i++)
                        {
                            fscanf(fp, "%le", &data[i][j][k][dataCount]);
                        }
                    }
                }
                dataCount++;
            }
        }
    }
    fclose(fp);
}

